import express from 'express';
import { asyncHandler, ApiError } from '../utils/errors.js';
import { promises as fs } from 'fs';
import path from 'path';

const router = express.Router();

/**
 * Get agent configuration
 */
router.get('/api/agent/config', asyncHandler(async (req, res) => {
  try {
    const agentEnvPath = path.join(process.cwd(), '..', 'agent', '.env');
    const envContent = await fs.readFile(agentEnvPath, 'utf-8');
    
    // Parse .env file into key-value pairs
    const config = {};
    const lines = envContent.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key && valueParts.length > 0) {
          config[key.trim()] = valueParts.join('=').trim();
        }
      }
    }

    // Mask sensitive values
    const maskedConfig = {};
    for (const [key, value] of Object.entries(config)) {
      if (key.includes('API_KEY') || key.includes('SECRET') || key.includes('PASSWORD')) {
        maskedConfig[key] = value ? '***' : '';
      } else {
        maskedConfig[key] = value;
      }
    }

    res.json({
      config: maskedConfig,
      configPath: agentEnvPath,
      requestId: req.requestId
    });
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new ApiError(
        'Agent configuration not found',
        'AGENT_CONFIG_NOT_FOUND',
        404,
        null,
        [
          'Run agent setup first: npm run agent:setup',
          'Create agent/.env file from agent/.env.example',
          'Verify agent directory exists'
        ]
      );
    }
    throw new ApiError(
      'Failed to read agent configuration',
      'AGENT_CONFIG_READ_ERROR',
      500,
      { originalError: error.message }
    );
  }
}));

/**
 * Update agent configuration
 */
router.post('/api/agent/config', asyncHandler(async (req, res) => {
  const { config } = req.body;
  
  if (!config || typeof config !== 'object') {
    throw new ApiError(
      'Invalid configuration data',
      'INVALID_CONFIG',
      400,
      null,
      ['Provide config as an object with key-value pairs']
    );
  }

  // Validate required fields
  const requiredFields = ['OPENAI_API_KEY', 'AO_PROCESS_ID'];
  const configKeys = Object.keys(config);
  const missingRequired = requiredFields.filter(field => 
    !configKeys.includes(field) || !config[field] || config[field] === 'sk-...' || config[field] === 'YOUR_AVATAR_PROCESS_ID_HERE'
  );

  if (missingRequired.length > 0) {
    throw new ApiError(
      `Missing or invalid required configuration: ${missingRequired.join(', ')}`,
      'MISSING_REQUIRED_CONFIG',
      400,
      { missingFields: missingRequired },
      [
        'Provide valid OpenAI API key',
        'Set proper AO_PROCESS_ID after deployment',
        'Remove placeholder values'
      ]
    );
  }

  try {
    const agentEnvPath = path.join(process.cwd(), '..', 'agent', '.env');
    
    // Build .env content
    const envLines = [];
    envLines.push('# RATi Agent Configuration');
    envLines.push('# Generated by RATi Deployment Service');
    envLines.push(`# Updated: ${new Date().toISOString()}`);
    envLines.push('');
    
    // Add configuration entries
    for (const [key, value] of Object.entries(config)) {
      if (key && value !== undefined) {
        envLines.push(`${key}=${value}`);
      }
    }
    
    const envContent = envLines.join('\n');
    await fs.writeFile(agentEnvPath, envContent, 'utf-8');

    res.json({
      message: 'Agent configuration updated successfully',
      configPath: agentEnvPath,
      updatedFields: Object.keys(config),
      requestId: req.requestId
    });
  } catch (error) {
    throw new ApiError(
      'Failed to write agent configuration',
      'AGENT_CONFIG_WRITE_ERROR',
      500,
      { originalError: error.message },
      [
        'Check file permissions for agent/.env',
        'Ensure agent directory exists',
        'Verify disk space availability'
      ]
    );
  }
}));

/**
 * Get agent status
 */
router.get('/api/agent/status', asyncHandler(async (req, res) => {
  const status = {
    running: false,
    configured: false,
    lastSeen: null,
    error: null,
    processId: null,
    requestId: req.requestId
  };

  try {
    // Check if configuration exists
    const agentEnvPath = path.join(process.cwd(), '..', 'agent', '.env');
    await fs.access(agentEnvPath);
    status.configured = true;
    
    // Try to read process ID from environment
    const envContent = await fs.readFile(agentEnvPath, 'utf-8');
    const processIdMatch = envContent.match(/ARWEAVE_PROCESS_ID=(.+)/);
    if (processIdMatch) {
      status.processId = processIdMatch[1].trim();
    }
    
    // Check if agent is running by looking for seed.json with agent info
    try {
      const seedPath = path.join('/app/project-root', 'seed.json');
      const seedContent = await fs.readFile(seedPath, 'utf-8');
      const seedData = JSON.parse(seedContent);
      
      if (seedData.agent?.processId) {
        status.running = true;
        status.processId = seedData.agent.processId;
        status.lastSeen = seedData.timestamp;
      }
    } catch {
      // seed.json doesn't exist or is invalid
    }
    
  } catch {
    status.configured = false;
    status.error = 'Agent not configured - missing .env file';
  }

  res.json(status);
}));

/**
 * Start agent (trigger agent launch)
 */
router.post('/api/agent/start', asyncHandler(async (req, res) => {
  try {
    // Check if agent is configured
    const agentEnvPath = path.join(process.cwd(), '..', 'agent', '.env');
    await fs.access(agentEnvPath);
    
    // Check if seed.json exists with agent info
    const seedPath = path.join('/app/project-root', 'seed.json');
    const seedContent = await fs.readFile(seedPath, 'utf-8');
    const seedData = JSON.parse(seedContent);
    
    if (!seedData.agent?.processId) {
      throw new ApiError(
        'Agent not deployed yet',
        'AGENT_NOT_DEPLOYED',
        400,
        null,
        ['Deploy agent first using /api/deploy/agent']
      );
    }
    
    // In a full implementation, this would start the agent Docker container
    // For now, we'll just return success if the configuration is valid
    res.json({
      message: 'Agent start requested - configuration validated',
      status: 'ready',
      processId: seedData.agent.processId,
      requestId: req.requestId
    });
    
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new ApiError(
        'Agent not configured or deployed',
        'AGENT_NOT_READY',
        400,
        null,
        ['Configure agent first', 'Ensure agent is deployed']
      );
    }
    throw error;
  }
}));

/**
 * Stop agent
 */
router.post('/api/agent/stop', asyncHandler(async (req, res) => {
  // TODO: Implement agent stop logic
  
  res.json({
    message: 'Agent stop requested',
    status: 'stopping',
    requestId: req.requestId
  });
}));

/**
 * Get agent logs
 */
router.get('/api/agent/logs', asyncHandler(async (req, res) => {
  const { lines = 100 } = req.query;
  
  // TODO: Implement actual log retrieval
  // This could read from Docker logs, log files, or a logging service
  
  const logs = [
    { timestamp: new Date().toISOString(), level: 'info', message: 'Agent logs endpoint - implementation pending' },
    { timestamp: new Date().toISOString(), level: 'info', message: `Requested ${lines} lines` }
  ];

  res.json({
    logs,
    totalLines: logs.length,
    requestedLines: parseInt(lines),
    requestId: req.requestId
  });
}));

export default router;
