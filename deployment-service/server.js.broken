import express from 'express';
import cors from 'cors';
import { WebSocketServer, WebSocket } from 'ws';
import { createServer } from 'http';
import { promises as fs } from 'fs';
import { createDataItemSigner, message, spawn as aoSpawn } from '@permaweb/aoconnect';
import { v4 as uuidv4 } from 'uuid';
import axios from 'axios';
import Arweave from 'arweave';
import path from 'path';
import crypto from 'crypto';

// Polyfill crypto for ao-connect in containerized environments
if (!globalThis.crypto) {
  globalThis.crypto = crypto.webcrypto || crypto;
}

// Enhanced error handling utilities
class ApiError extends Error {
  constructor(message, code = 'INTERNAL_ERROR', statusCode = 500, details = null, suggestions = []) {
    super(message);
    this.name = 'ApiError';
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.suggestions = suggestions;
  }
}

function createErrorResponse(error, req = null) {
  const isApiError = error instanceof ApiError;
  
  const response = {
    error: {
      code: isApiError ? error.code : 'INTERNAL_ERROR',
      message: isApiError ? error.message : 'An unexpected error occurred',
      timestamp: new Date().toISOString(),
      requestId: req?.headers['x-request-id'] || uuidv4()
    }
  };

  if (isApiError) {
    if (error.details) response.error.details = error.details;
    if (error.suggestions.length > 0) response.error.suggestions = error.suggestions;
  }

  // Add debug info in development
  if (process.env.NODE_ENV === 'development') {
    response.error.stack = error.stack;
    if (req) {
      response.error.request = {
        method: req.method,
        url: req.originalUrl,
        headers: req.headers,
        body: req.body
      };
    }
  }

  return response;
}

// Enhanced logging with context
function logError(error, context = {}) {
  const timestamp = new Date().toISOString();
  const contextStr = Object.keys(context).length > 0 ? JSON.stringify(context) : '';
  
  console.error(`[${timestamp}] ERROR: ${error.message}`);
  if (contextStr) console.error(`[${timestamp}] CONTEXT: ${contextStr}`);
  if (error.stack) console.error(`[${timestamp}] STACK: ${error.stack}`);
}

// Validation helpers
function validateRequiredFields(data, requiredFields) {
  const missing = requiredFields.filter(field => !data[field]);
  if (missing.length > 0) {
    throw new ApiError(
      `Missing required fields: ${missing.join(', ')}`,
      'VALIDATION_ERROR',
      400,
      { missingFields: missing },
      [`Please provide values for: ${missing.join(', ')}`]
    );
  }
}

function validateEnvironment() {
  const requiredEnvVars = ['ARWEAVE_HOST', 'ARWEAVE_PORT'];
  const missing = requiredEnvVars.filter(varName => !process.env[varName]);
  
  if (missing.length > 0) {
    throw new ApiError(
      `Missing required environment variables: ${missing.join(', ')}`,
      'CONFIGURATION_ERROR',
      503,
      { missingEnvVars: missing },
      [
        'Check your .env file or environment configuration',
        'Ensure all required environment variables are set',
        'Restart the service after configuration changes'
      ]
    );
  }
}

// Logging helper
function addLog(deploymentId, level, message, data = null) {
  const deployment = deployments.get(deploymentId);
  if (deployment) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      data
    };
    deployment.logs.push(logEntry);
    broadcast({ type: 'deployment_log', deploymentId, log: logEntry });
    console.log(`[${deploymentId}] ${level.toUpperCase()}: ${message}`);
  }
}

// Update deployment status
function updateDeployment(id, updates) {
  const deployment = deployments.get(id);
  if (deployment) {
    Object.assign(deployment, updates);
    broadcast({ type: 'deployment_updated', deployment });
  }
}

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Arweave configuRATion
const arweave = Arweave.init({
  host: process.env.ARWEAVE_HOST || 'arlocal',
  port: parseInt(process.env.ARWEAVE_PORT) || 1984,
  protocol: process.env.ARWEAVE_PROTOCOL || 'http'
});

// Auto-genesis detection and seed.json creation
async function initializeGenesis() {
  try {
    console.log('üîç Checking for existing genesis transaction...');
    
    // Check if seed.json already exists
    const seedPath = path.join(process.cwd(), 'seed.json');
    let seedData = null;
    
    try {
      const seedContent = await fs.readFile(seedPath, 'utf-8');
      seedData = JSON.parse(seedContent);
      console.log(`üìÑ Found existing seed.json with genesis: ${seedData.genesis?.txid}`);
      
      // Verify the genesis transaction exists
      if (seedData.genesis?.txid) {
        try {
          await axios.get(`${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}/tx/${seedData.genesis.txid}`);
          console.log('‚úÖ Genesis transaction verified on Arweave');
          return seedData;
        } catch {
          console.log('‚ö†Ô∏è Genesis transaction not found on Arweave, will create new one');
        }
      }
    } catch {
      console.log('üìù No existing seed.json found, will create new genesis');
    }
    
    // Create new genesis transaction
    console.log('üöÄ Creating new genesis transaction...');
    
    // Load wallet
    const walletPath = path.join(process.cwd(), '..', 'wallets', 'wallet.json');
    let key;
    try {
      key = JSON.parse(await fs.readFile(walletPath, 'utf-8'));
    } catch {
      // Try alternative path in Docker
      const dockerWalletPath = '/app/wallets/wallet.json';
      key = JSON.parse(await fs.readFile(dockerWalletPath, 'utf-8'));
    }
    const walletAddress = await arweave.wallets.jwkToAddress(key);
    
    // Ensure wallet has funds
    const balance = await arweave.wallets.getBalance(walletAddress);
    console.log(`üí∞ Wallet balance: ${arweave.ar.winstonToAr(balance)} AR`);
    
    if (balance === '0') {
      console.log('üíé Wallet needs funds, attempting to mint...');
      try {
        await axios.post(`http://localhost:3032/api/arweave/mint/${walletAddress}/1`);
        console.log('‚úÖ Successfully minted 1 AR to wallet');
      } catch (error) {
        console.error('‚ùå Failed to mint AR tokens:', error.message);
        throw new Error('Wallet has no funds and minting failed');
      }
    }
    
    // Load genesis content
    let scroll1Path = path.join(process.cwd(), '..', 'scrolls', 'scroll-1.md');
    let scroll2Path = path.join(process.cwd(), '..', 'scrolls', 'scroll-2.md');
    
    // Try Docker paths if local paths don't exist
    try {
      await fs.access(scroll1Path);
    } catch {
      scroll1Path = '/app/scrolls/scroll-1.md';
    }
    
    try {
      await fs.access(scroll2Path);
    } catch {
      scroll2Path = '/app/scrolls/scroll-2.md';
    }
    
    const scroll1 = await fs.readFile(scroll1Path, 'utf-8');
    const scroll2 = await fs.readFile(scroll2Path, 'utf-8');
    const foundingText = `# The Founding Scrolls\n\n## Scroll I\n\n${scroll1}\n\n## Scroll II\n\n${scroll2}`;
    
    // Create and post genesis transaction
    const transaction = await arweave.createTransaction({ data: foundingText }, key);
    transaction.addTag('App-Name', 'RATi');
    transaction.addTag('Content-Type', 'text/markdown');
    transaction.addTag('Type', 'Genesis-Scroll');
    transaction.addTag('Version', '1.0');
    
    await arweave.transactions.sign(transaction, key);
    
    console.log('üì§ Posting genesis transaction...');
    const response = await arweave.transactions.post(transaction);
    
    if (response.status === 200) {
      console.log('‚úÖ Genesis transaction posted successfully');
      
      // Create seed.json with deployment info
      const seedData = {
        timestamp: new Date().toISOString(),
        deployment: {
          service: 'RATi Deployment Service',
          version: '1.0.0',
          environment: process.env.NODE_ENV || 'development'
        },
        arweave: {
          host: arweave.api.config.host,
          port: arweave.api.config.port,
          protocol: arweave.api.config.protocol
        },
        genesis: {
          txid: transaction.id,
          address: walletAddress,
          timestamp: new Date().toISOString(),
          status: 'deployed'
        },
        processes: {
          oracle: null, // Will be populated when oracle is deployed
          cell: null,   // Will be populated when cell is deployed
          agent: null   // Will be populated when agent is deployed
        }
      };
      
      await fs.writeFile(seedPath, JSON.stringify(seedData, null, 2));
      console.log(`üìÑ Created seed.json with genesis: ${transaction.id}`);
      console.log(`üîó View at: ${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}/${transaction.id}`);
      
      return seedData;
    } else {
      throw new Error(`Failed to post genesis transaction: ${response.status}`);
    }
    
  } catch (error) {
    console.error('‚ùå Failed to initialize genesis:', error.message);
    throw error;
  }
}

// Update seed.json with new process information
async function updateSeedWithProcess(processType, processId, additionalData = {}) {
  try {
    const seedPath = path.join(process.cwd(), 'seed.json');
    let seedData = {};
    
    // Load existing seed data
    try {
      const seedContent = await fs.readFile(seedPath, 'utf-8');
      seedData = JSON.parse(seedContent);
    } catch {
      console.log('‚ö†Ô∏è No seed.json found, creating new one');
      seedData = {
        timestamp: new Date().toISOString(),
        deployment: {},
        arweave: {},
        genesis: {},
        processes: {}
      };
    }
    
    // Update the process information
    seedData.processes[processType] = {
      id: processId,
      timestamp: new Date().toISOString(),
      status: 'deployed',
      ...additionalData
    };
    
    // Update the overall timestamp
    seedData.lastUpdated = new Date().toISOString();
    
    await fs.writeFile(seedPath, JSON.stringify(seedData, null, 2));
    console.log(`üìÑ Updated seed.json with ${processType}: ${processId}`);
    
    return seedData;
  } catch (error) {
    console.error(`‚ùå Failed to update seed.json with ${processType}:`, error.message);
    throw error;
  }
}

// Arlocal utilities
async function checkArweaveStatus() {
  try {
    const info = await arweave.network.getInfo();
    console.log('Arweave network info:', info);
    return info;
  } catch (error) {
    console.error('Failed to get Arweave network info:', error.message);
    throw error;
  }
}

async function mineBlock() {
  try {
    const response = await axios.get(`${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}/mine`);
    console.log('Block mined successfully:', response.data);
    return response.data;
  } catch (error) {
    console.error('Failed to mine block:', error.message);
    throw error;
  }
}

async function getWalletBalance(address) {
  try {
    const balance = await arweave.wallets.getBalance(address);
    console.log(`Wallet ${address} balance: ${arweave.ar.winstonToAr(balance)} AR`);
    return balance;
  } catch (error) {
    console.error('Failed to get wallet balance:', error.message);
    throw error;
  }
}

// Ollama configuration (for future use)
const _OLLAMA_HOST = process.env.OLLAMA_HOST || 'localhost';
const _OLLAMA_PORT = process.env.OLLAMA_PORT || '11434';
const _OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'gemma3';
const _OLLAMA_BASE_URL = `http://${_OLLAMA_HOST}:${_OLLAMA_PORT}`;

// In-memory storage for deployment status
const deployments = new Map();
const activeConnections = new Set();

// WebSocket connection handling
wss.on('connection', (ws) => {
  activeConnections.add(ws);
  console.log('Client connected to deployment service');

  ws.on('close', () => {
    activeConnections.delete(ws);
    console.log('Client disconnected from deployment service');
  });

  // Send current deployment status
  ws.send(JSON.stringify({
    type: 'status',
    deployments: Array.from(deployments.values())
  }));
});

// Broadcast to all connected clients
function broadcast(message) {
  const data = JSON.stringify(message);
  activeConnections.forEach(ws => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(data);
    }
  });
}

// API Routes

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Arlocal utility endpoints
app.get('/api/arweave/status', async (req, res) => {
  try {
    const info = await checkArweaveStatus();
    res.json({ success: true, info });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/arweave/mine', async (req, res) => {
  try {
    const result = await mineBlock();
    res.json({ success: true, result });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/api/wallet/balance', async (req, res) => {
  try {
    const wallet = await loadWallet();
    const address = await arweave.wallets.jwkToAddress(wallet);
    const balance = await getWalletBalance(address);
    res.json({ 
      success: true, 
      address,
      balance,
      balanceAR: arweave.ar.winstonToAr(balance)
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Arweave proxy endpoints
app.get('/arweave/:txid', async (req, res) => {
  try {
    const { txid } = req.params;
    console.log(`Proxying Arweave request for transaction: ${txid}`);
    
    const arweaveUrl = `${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}/${txid}`;
    const response = await axios.get(arweaveUrl, {
      responseType: 'stream',
      timeout: 30000
    });
    
    // Forward headers
    if (response.headers['content-type']) {
      res.set('Content-Type', response.headers['content-type']);
    }
    if (response.headers['content-length']) {
      res.set('Content-Length', response.headers['content-length']);
    }
    
    // Pipe the response
    response.data.pipe(res);
  } catch (error) {
    console.error(`Arweave proxy error for ${req.params.txid}:`, error.message);
    if (error.response?.status) {
      res.status(error.response.status).json({ 
        error: 'Transaction not found',
        txid: req.params.txid 
      });
    } else {
      res.status(500).json({ 
        error: 'Failed to fetch transaction',
        txid: req.params.txid 
      });
    }
  }
});

// Arweave network info proxy
app.get('/arweave-info', async (req, res) => {
  try {
    console.log('Proxying Arweave network info request');
    const info = await arweave.network.getInfo();
    res.json(info);
  } catch (error) {
    console.error('Arweave info proxy error:', error.message);
    res.status(500).json({ error: 'Failed to get network info' });
  }
});

// Arweave mint tokens (arlocal only)
app.post('/api/arweave/mint/:address/:amount', async (req, res) => {
  try {
    const { address, amount } = req.params;
    
    // Only allow minting if we're connected to arlocal
    if (arweave.api.config.host !== 'arlocal' && arweave.api.config.host !== 'localhost') {
      return res.status(400).json({ 
        success: false, 
        error: 'Minting only allowed on local arlocal instances' 
      });
    }
    
    console.log(`Minting ${amount} winston to address: ${address}`);
    
    // Try different arlocal access methods
    let mintUrl;
    let response;
    
    try {
      // Method 1: Direct container access
      mintUrl = `http://arlocal:1984/mint/${address}/${amount}`;
      response = await axios.get(mintUrl);
    } catch (error1) {
      try {
        // Method 2: Via localhost
        mintUrl = `http://localhost:1984/mint/${address}/${amount}`;
        response = await axios.get(mintUrl);
      } catch (error2) {
        throw new Error(`Failed both container (${error1.message}) and localhost (${error2.message}) access`);
      }
    }
    
    console.log(`Mint response:`, response.data);
    
    // Get updated balance
    const balance = await arweave.wallets.getBalance(address);
    const balanceAR = arweave.ar.winstonToAr(balance);
    
    res.json({ 
      success: true, 
      address,
      amount,
      amountAR: arweave.ar.winstonToAr(amount),
      newBalance: balance,
      newBalanceAR: balanceAR,
      message: `Successfully minted ${arweave.ar.winstonToAr(amount)} AR to ${address}`
    });
  } catch (error) {
    console.error('Mint error:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message,
      details: error.response?.data 
    });
  }
});

// Convenience endpoint to mint to current wallet
app.post('/api/wallet/mint/:amount?', async (req, res) => {
  try {
    const wallet = await loadWallet();
    const address = await arweave.wallets.jwkToAddress(wallet);
    const amount = req.params.amount || '1000000000000'; // Default 1 AR
    
    // Only allow minting if we're connected to arlocal
    if (arweave.api.config.host !== 'arlocal' && arweave.api.config.host !== 'localhost') {
      return res.status(400).json({ 
        success: false, 
        error: 'Minting only allowed on local arlocal instances' 
      });
    }
    
    console.log(`Minting ${amount} winston to wallet: ${address}`);
    
    const mintUrl = `${arweave.api.config.protocol}://${arweave.api.config.host}:${arweave.api.config.port}/mint/${address}/${amount}`;
    const response = await axios.post(mintUrl);
    
    console.log(`Mint response:`, response.data);
    
    // Get updated balance
    const balance = await arweave.wallets.getBalance(address);
    const balanceAR = arweave.ar.winstonToAr(balance);
    
    res.json({ 
      success: true, 
      address,
      amount,
      amountAR: arweave.ar.winstonToAr(amount),
      newBalance: balance,
      newBalanceAR: balanceAR,
      message: `Successfully minted ${arweave.ar.winstonToAr(amount)} AR to wallet`
    });
  } catch (error) {
    console.error('Wallet mint error:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message,
      details: error.response?.data 
    });
  }
});

// Get seed.json contents
app.get('/api/seed', async (req, res) => {
  try {
    const seedPath = path.join(process.cwd(), 'seed.json');
    const seedContent = await fs.readFile(seedPath, 'utf-8');
    const seedData = JSON.parse(seedContent);
    res.json(seedData);
  } catch (error) {
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'seed.json not found' });
    } else {
      console.error('Error reading seed.json:', error);
      res.status(500).json({ error: 'Failed to read seed.json' });
    }
  }
});

// Get all deployments
app.get('/api/deployments', (req, res) => {
  res.json(Array.from(deployments.values()));
});

// Get specific deployment
app.get('/api/deployments/:id', (req, res) => {
  const deployment = deployments.get(req.params.id);
  if (!deployment) {
    return res.status(404).json({ error: 'Deployment not found' });
  }
  res.json(deployment);
});

// Get available scrolls
app.get('/api/scrolls', async (req, res) => {
  try {
    const scrollsDir = '/app/scrolls';
    const entries = await fs.readdir(scrollsDir, { withFileTypes: true });
    const scrolls = [];
    
    for (const entry of entries) {
      if (entry.isFile() && entry.name.endsWith('.md')) {
        scrolls.push({
          name: entry.name.replace('.md', ''),
          file: entry.name,
          type: 'markdown'
        });
      }
    }
    
    res.json(scrolls);
  } catch (error) {
    console.error('Error reading scrolls:', error);
    res.status(500).json({ error: 'Failed to read scrolls directory' });
  }
});

// Get available wallets
app.get('/api/wallets', async (req, res) => {
  try {
    const walletsDir = '/app/wallets';
    const entries = await fs.readdir(walletsDir);
    const wallets = entries
      .filter(entry => entry.endsWith('.json'))
      .map(entry => ({
        name: entry.replace('.json', ''),
        file: entry
      }));
    res.json(wallets);
  } catch (error) {
    console.error('Error reading wallets:', error);
    res.status(500).json({ error: 'Failed to read wallets directory' });
  }
});

// Deploy genesis scroll
app.post('/api/deploy/genesis', async (req, res) => {
  try {
    const deploymentId = uuidv4();
    const deployment = {
      id: deploymentId,
      type: 'genesis',
      status: 'starting',
      startTime: new Date().toISOString(),
      logs: []
    };

    deployments.set(deploymentId, deployment);
    broadcast({ type: 'deployment_started', deployment });

    // Execute deployment
    deployGenesis(deployment);

    res.json({ deploymentId, message: 'Genesis deployment started' });
  } catch (error) {
    console.error('Deploy genesis error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Deploy oracle
app.post('/api/deploy/oracle', async (req, res) => {
  try {
    const deploymentId = uuidv4();
    const deployment = {
      id: deploymentId,
      type: 'oracle',
      status: 'starting',
      startTime: new Date().toISOString(),
      logs: []
    };

    deployments.set(deploymentId, deployment);
    broadcast({ type: 'deployment_started', deployment });

    // Execute deployment
    deployOracle(deployment);

    res.json({ deploymentId, message: 'Oracle deployment started' });
  } catch (error) {
    console.error('Deploy oracle error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Deploy agent
app.post('/api/deploy/agent', async (req, res) => {
  try {
    const deploymentId = uuidv4();
    const deployment = {
      id: deploymentId,
      type: 'agent',
      status: 'starting',
      startTime: new Date().toISOString(),
      logs: []
    };

    deployments.set(deploymentId, deployment);
    broadcast({ type: 'deployment_started', deployment });

    // Execute deployment
    deployAgent(deployment);

    res.json({ deploymentId, message: 'Agent deployment started' });
  } catch (error) {
    console.error('Deploy agent error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Summon agent with personality
app.post('/api/summon', async (req, res) => {
  try {
    const { personalityPrompt, agentName } = req.body;
    
    if (!personalityPrompt) {
      return res.status(400).json({ error: 'personalityPrompt is required' });
    }

    const deploymentId = uuidv4();
    const deployment = {
      id: deploymentId,
      type: 'summon',
      status: 'starting',
      startTime: new Date().toISOString(),
      logs: [],
      agentName: agentName || 'RATi-AI-Agent'
    };

    deployments.set(deploymentId, deployment);
    broadcast({ type: 'deployment_started', deployment });

    // Execute summoning
    summonAgent(deployment, personalityPrompt);

    res.json({ deploymentId, message: 'Agent summoning started' });
  } catch (error) {
    console.error('Summon agent error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Full deployment pipeline
app.post('/api/deploy/full', async (req, res) => {
  try {
    const deploymentId = uuidv4();
    const deployment = {
      id: deploymentId,
      type: 'full',
      status: 'starting',
      startTime: new Date().toISOString(),
      logs: []
    };

    deployments.set(deploymentId, deployment);
    broadcast({ type: 'deployment_started', deployment });

    // Execute full deployment
    deployFull(deployment);

    res.json({ deploymentId, message: 'Full deployment started' });
  } catch (error) {
    console.error('Deploy full error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Reset deployment state
app.post('/api/reset', async (req, res) => {
  try {
    deployments.clear();
    broadcast({ type: 'deployments_reset' });
    res.json({ message: 'Deployment state reset successfully' });
  } catch (error) {
    console.error('Reset error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Configuration endpoints
app.get('/api/agent/config', async (req, res) => {
  try {
    const configPath = '/app/agent/.env.config';
    let config = {};
    
    try {
      const configData = await fs.readFile(configPath, 'utf-8');
      config = JSON.parse(configData);
    } catch {
      // Config file doesn't exist yet, return default config
      config = {
        openai: {
          apiKey: '',
          apiUrl: 'https://api.openai.com/v1',
          model: 'gpt-4'
        },
        farcaster: {
          apiKey: '',
          signerUuid: '',
          enabled: false
        },
        matrix: {
          homeserver: 'https://matrix.org',
          accessToken: '',
          userId: '',
          roomIds: '',
          enabled: false
        },
        agent: {
          pollingInterval: 15000,
          actionHistoryLength: 20,
          enableAutoPost: true,
          enableEngagement: true
        },
        arweave: {
          network: 'mainnet',
          host: 'arweave.net',
          port: 443,
          protocol: 'https',
          processId: ''
        }
      };
    }
    
    // Remove sensitive data before sending to frontend
    const safeConfig = JSON.parse(JSON.stringify(config));
    if (safeConfig.openai?.apiKey) {
      safeConfig.openai.apiKey = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + safeConfig.openai.apiKey.slice(-4);
    }
    if (safeConfig.farcaster?.apiKey) {
      safeConfig.farcaster.apiKey = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + safeConfig.farcaster.apiKey.slice(-4);
    }
    if (safeConfig.matrix?.accessToken) {
      safeConfig.matrix.accessToken = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + safeConfig.matrix.accessToken.slice(-4);
    }
    
    res.json(safeConfig);
  } catch (error) {
    console.error('Error loading configuration:', error);
    res.status(500).json({ error: 'Failed to load configuration' });
  }
});

app.post('/api/agent/config', async (req, res) => {
  try {
    const config = req.body;
    
    // Validate required fields
    if (!config.openai?.apiKey || config.openai.apiKey.startsWith('‚Ä¢‚Ä¢‚Ä¢‚Ä¢')) {
      return res.status(400).json({ error: 'OpenAI API key is required' });
    }
    
    // Create environment file for the agent
    const envContent = [
      `# Agent Configuration - Generated ${new Date().toISOString()}`,
      '',
      '# Core Settings',
      `AO_PROCESS_ID=${config.arweave?.processId || ''}`,
      `OPENAI_API_KEY=${config.openai?.apiKey || ''}`,
      `OPENAI_API_URL=${config.openai?.apiUrl || 'https://api.openai.com/v1'}`,
      `POLLING_INTERVAL=${config.agent?.pollingInterval || 15000}`,
      `AI_ACTION_HISTORY_LENGTH=${config.agent?.actionHistoryLength || 20}`,
      '',
      '# Arweave Settings',
      `# Network: ${config.arweave?.network || 'mainnet'}`,
      `ARWEAVE_HOST=${config.arweave?.host || 'arweave.net'}`,
      `ARWEAVE_PORT=${config.arweave?.port || 443}`,
      `ARWEAVE_PROTOCOL=${config.arweave?.protocol || 'https'}`,
      '',
      '# Farcaster Integration',
      `FARCASTER_API_KEY=${config.farcaster?.enabled ? config.farcaster?.apiKey || '' : ''}`,
      `FARCASTER_SIGNER_UUID=${config.farcaster?.enabled ? config.farcaster?.signerUuid || '' : ''}`,
      '',
      '# Matrix Integration',
      `MATRIX_HOMESERVER=${config.matrix?.enabled ? config.matrix?.homeserver || '' : ''}`,
      `MATRIX_ACCESS_TOKEN=${config.matrix?.enabled ? config.matrix?.accessToken || '' : ''}`,
      `MATRIX_USER_ID=${config.matrix?.enabled ? config.matrix?.userId || '' : ''}`,
      `MATRIX_ROOM_IDS=${config.matrix?.enabled ? config.matrix?.roomIds || '' : ''}`,
      '',
      '# Agent Behavior',
      `ENABLE_AUTO_POST=${config.agent?.enableAutoPost ? 'true' : 'false'}`,
      `ENABLE_ENGAGEMENT=${config.agent?.enableEngagement ? 'true' : 'false'}`
    ].join('\n');
    
    // Save the configuration
    const configPath = '/app/agent/.env.config';
    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
    
    // Save the environment file
    const envPath = '/app/agent/.env';
    await fs.writeFile(envPath, envContent);
    
    res.json({ message: 'Configuration saved successfully' });
  } catch (error) {
    console.error('Error saving configuration:', error);
    res.status(500).json({ error: 'Failed to save configuration' });
  }
});

app.post('/api/agent/test-connection/:service', async (req, res) => {
  try {
    const service = req.params.service;
    const config = req.body;
    
    switch (service) {
      case 'openai':
        try {
          const response = await axios.post(
            `${config.apiUrl || 'https://api.openai.com/v1'}/chat/completions`,
            {
              model: config.model || 'gpt-4',
              messages: [{ role: 'user', content: 'Hello' }],
              max_tokens: 5
            },
            {
              headers: {
                'Authorization': `Bearer ${config.apiKey}`,
                'Content-Type': 'application/json'
              },
              timeout: 10000
            }
          );
          
          if (response.status === 200) {
            res.json({ success: true, message: 'OpenAI connection successful' });
          } else {
            res.json({ success: false, error: 'OpenAI API returned non-200 status' });
          }
        } catch (error) {
          res.json({ 
            success: false, 
            error: `OpenAI connection failed: ${error.response?.data?.error?.message || error.message}` 
          });
        }
        break;
        
      case 'farcaster':
        try {
          const response = await axios.get('https://api.neynar.com/v2/farcaster/user/bulk', {
            headers: {
              'api_key': config.apiKey,
              'Content-Type': 'application/json'
            },
            params: {
              fids: '3'  // Test with FID 3 (dwr.eth)
            },
            timeout: 10000
          });
          
          if (response.status === 200) {
            res.json({ success: true, message: 'Farcaster connection successful' });
          } else {
            res.json({ success: false, error: 'Farcaster API returned non-200 status' });
          }
        } catch (error) {
          res.json({ 
            success: false, 
            error: `Farcaster connection failed: ${error.response?.data?.message || error.message}` 
          });
        }
        break;
        
      case 'matrix':
        try {
          const response = await axios.get(`${config.homeserver}/_matrix/client/v3/account/whoami`, {
            headers: {
              'Authorization': `Bearer ${config.accessToken}`
            },
            timeout: 10000
          });
          
          if (response.status === 200) {
            res.json({ success: true, message: 'Matrix connection successful' });
          } else {
            res.json({ success: false, error: 'Matrix API returned non-200 status' });
          }
        } catch (error) {
          res.json({ 
            success: false, 
            error: `Matrix connection failed: ${error.response?.data?.error || error.message}` 
          });
        }
        break;
        
      default:
        res.status(400).json({ success: false, error: 'Unknown service' });
    }
  } catch (error) {
    console.error('Test connection error:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// Deployment functions
async function loadWallet() {
  const walletPath = '/app/wallets/wallet.json';
  try {
    const walletData = await fs.readFile(walletPath, 'utf-8');
    return JSON.parse(walletData);
  } catch (error) {
    throw new Error(`Failed to load wallet: ${error.message}`);
  }
}

async function deployGenesis(deployment) {
  try {
    updateDeployment(deployment.id, { status: 'deploying' });
    addLog(deployment.id, 'info', 'Starting genesis deployment');

    const wallet = await loadWallet();
    addLog(deployment.id, 'info', 'Wallet loaded successfully');

    // Check Arweave/arlocal status and wallet balance
    try {
      const arweaveInfo = await checkArweaveStatus();
      addLog(deployment.id, 'info', 'Arweave network status checked', { info: arweaveInfo });
      
      const address = await arweave.wallets.jwkToAddress(wallet);
      const balance = await getWalletBalance(address);
      addLog(deployment.id, 'info', `Wallet balance: ${arweave.ar.winstonToAr(balance)} AR`, { 
        address, 
        balance, 
        balanceAR: arweave.ar.winstonToAr(balance) 
      });

      // Mine a block to ensure arlocal is active
      if (process.env.ARWEAVE_HOST === 'arlocal' || arweave.api.config.host === 'arlocal') {
        await mineBlock();
        addLog(deployment.id, 'info', 'Mined block to ensure arlocal is active');
      }
    } catch (statusError) {
      addLog(deployment.id, 'warn', `Arweave status check failed: ${statusError.message}`, {
        error: statusError.message
      });
    }

    // Read genesis scrolls
    const scroll1Path = '/app/scrolls/scroll-1.md';
    const scroll2Path = '/app/scrolls/scroll-2.md';
    
    let genesisContent = '';
    
    try {
      const scroll1 = await fs.readFile(scroll1Path, 'utf-8');
      genesisContent += scroll1 + '\n\n';
      addLog(deployment.id, 'info', 'Loaded scroll-1.md');
    } catch {
      addLog(deployment.id, 'warn', 'scroll-1.md not found, skipping');
    }
    
    try {
      const scroll2 = await fs.readFile(scroll2Path, 'utf-8');
      genesisContent += scroll2;
      addLog(deployment.id, 'info', 'Loaded scroll-2.md');
    } catch {
      addLog(deployment.id, 'warn', 'scroll-2.md not found, skipping');
    }

    if (!genesisContent.trim()) {
      throw new Error('No genesis content found');
    }

    addLog(deployment.id, 'info', 'Creating genesis transaction on Arweave');

    const transaction = await arweave.createTransaction({
      data: genesisContent
    }, wallet);

    transaction.addTag('Type', 'Genesis-Scroll');
    transaction.addTag('App-Name', 'RATi');
    transaction.addTag('Content-Type', 'text/markdown');
    transaction.addTag('Version', '1.0');

    await arweave.transactions.sign(transaction, wallet);
    
    addLog(deployment.id, 'info', `Posting transaction ${transaction.id} to Arweave...`);
    addLog(deployment.id, 'debug', 'Transaction details', {
      id: transaction.id,
      data_size: transaction.data_size,
      reward: transaction.reward,
      target: transaction.target,
      tags: transaction.tags
    });

    try {
      const postResponse = await arweave.transactions.post(transaction);
      addLog(deployment.id, 'info', `Genesis transaction posted successfully: ${transaction.id}`, {
        response: postResponse
      });
    } catch (postError) {
      addLog(deployment.id, 'error', `Failed to post transaction ${transaction.id}`, {
        error: postError.message,
        response: postError.response?.data,
        status: postError.response?.status,
        statusText: postError.response?.statusText,
        headers: postError.response?.headers
      });
      throw postError;
    }

    // Update seed.json with genesis info (this should also update the existing genesis if auto-created)
    try {
      const seedPath = path.join(process.cwd(), 'seed.json');
      let seedData = {};
      
      try {
        const seedContent = await fs.readFile(seedPath, 'utf-8');
        seedData = JSON.parse(seedContent);
      } catch {
        seedData = {
          timestamp: new Date().toISOString(),
          deployment: {},
          arweave: {},
          processes: {}
        };
      }
      
      seedData.genesis = {
        txid: transaction.id,
        timestamp: new Date().toISOString(),
        status: 'deployed'
      };
      seedData.lastUpdated = new Date().toISOString();
      
      await fs.writeFile(seedPath, JSON.stringify(seedData, null, 2));
      addLog(deployment.id, 'info', 'Updated seed.json with genesis transaction');
    } catch (seedError) {
      addLog(deployment.id, 'warn', `Failed to update seed.json: ${seedError.message}`);
    }

    updateDeployment(deployment.id, { 
      status: 'completed',
      endTime: new Date().toISOString(),
      result: { txid: transaction.id }
    });

  } catch (error) {
    addLog(deployment.id, 'error', `Genesis deployment failed: ${error.message}`, {
      stack: error.stack,
      response: error.response?.data,
      status: error.response?.status,
      statusText: error.response?.statusText
    });
    updateDeployment(deployment.id, { 
      status: 'failed',
      endTime: new Date().toISOString(),
      error: error.message
    });
  }
}

async function deployOracle(deployment) {
  try {
    updateDeployment(deployment.id, { status: 'deploying' });
    addLog(deployment.id, 'info', 'Starting oracle deployment');

    const wallet = await loadWallet();
    const signer = createDataItemSigner(wallet);
    addLog(deployment.id, 'info', 'Wallet and signer prepared');

    addLog(deployment.id, 'info', 'Spawning oracle process');

    const oracleProcessId = await aoSpawn({
      module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk", 
      scheduler: '_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA',
      signer,
      tags: [{ name: 'Name', value: 'RATi-Oracle' }]
    });

    addLog(deployment.id, 'info', `Oracle process spawned: ${oracleProcessId}`);

    // Initialize oracle with Lua code
    const oracleCodePath = '/app/src/oracle/oracle.lua';
    const oracleCode = await fs.readFile(oracleCodePath, 'utf-8');
    
    await message({
      process: oracleProcessId,
      signer,
      data: oracleCode,
      tags: [{ name: 'Action', value: 'Eval' }]
    });

    addLog(deployment.id, 'info', 'Oracle initialized with Lua code');

    // Update seed.json with oracle process info
    try {
      await updateSeedWithProcess('oracle', oracleProcessId, {
        name: 'RATi-Oracle',
        type: 'oracle'
      });
      addLog(deployment.id, 'info', 'Updated seed.json with oracle process');
    } catch (seedError) {
      addLog(deployment.id, 'warn', `Failed to update seed.json: ${seedError.message}`);
    }

    updateDeployment(deployment.id, { 
      status: 'completed',
      endTime: new Date().toISOString(),
      result: { processId: oracleProcessId }
    });

  } catch (error) {
    addLog(deployment.id, 'error', `Oracle deployment failed: ${error.message}`);
    updateDeployment(deployment.id, { 
      status: 'failed',
      endTime: new Date().toISOString(),
      error: error.message
    });
  }
}

async function deployAgent(deployment) {
  try {
    updateDeployment(deployment.id, { status: 'deploying' });
    addLog(deployment.id, 'info', 'Starting agent deployment');

    const wallet = await loadWallet();
    const signer = createDataItemSigner(wallet);
    
    // Read agent prompt template
    const promptPath = '/app/agent/prompt.md';
    const promptData = await fs.readFile(promptPath, 'utf-8');
    
    addLog(deployment.id, 'info', 'Spawning agent process');
    
    const agentProcessId = await aoSpawn({
      module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
      scheduler: '_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA',
      signer,
      tags: [{ name: 'Name', value: 'RATi-AI-Agent' }]
    });

    addLog(deployment.id, 'info', `Agent process spawned: ${agentProcessId}`);

    // Initialize with avatar blueprint
    const avatarCodePath = '/app/src/avatar/avatar.lua';
    const avatarCode = await fs.readFile(avatarCodePath, 'utf-8');
    
    await message({
      process: agentProcessId,
      signer,
      data: avatarCode,
      tags: [{ name: 'Action', value: 'Eval' }]
    });

    addLog(deployment.id, 'info', 'Agent initialized with avatar code');

    // Store personality on-chain
    const personalityTx = await arweave.createTransaction({
      data: promptData
    }, wallet);

    personalityTx.addTag('Type', 'Agent-Personality');
    personalityTx.addTag('Agent-Process-ID', agentProcessId);
    personalityTx.addTag('Content-Type', 'text/markdown');

    await arweave.transactions.sign(personalityTx, wallet);
    
    addLog(deployment.id, 'info', `Posting agent personality transaction ${personalityTx.id} to Arweave...`);
    addLog(deployment.id, 'debug', 'Personality transaction details', {
      id: personalityTx.id,
      data_size: personalityTx.data_size,
      reward: personalityTx.reward,
      target: personalityTx.target,
      tags: personalityTx.tags
    });

    try {
      const postResponse = await arweave.transactions.post(personalityTx);
      addLog(deployment.id, 'info', `Agent personality transaction posted successfully: ${personalityTx.id}`, {
        response: postResponse
      });
    } catch (postError) {
      addLog(deployment.id, 'error', `Failed to post personality transaction ${personalityTx.id}`, {
        error: postError.message,
        response: postError.response?.data,
        status: postError.response?.status,
        statusText: postError.response?.statusText,
        headers: postError.response?.headers
      });
      throw postError;
    }

    addLog(deployment.id, 'info', `Agent personality stored on-chain: ${personalityTx.id}`);

    // Update seed.json with agent process info
    try {
      await updateSeedWithProcess('agent', agentProcessId, {
        name: 'RATi-AI-Agent',
        type: 'agent',
        personalityTxid: personalityTx.id
      });
      addLog(deployment.id, 'info', 'Updated seed.json with agent process');
    } catch (seedError) {
      addLog(deployment.id, 'warn', `Failed to update seed.json: ${seedError.message}`);
    }

    updateDeployment(deployment.id, { 
      status: 'completed',
      endTime: new Date().toISOString(),
      result: { 
        processId: agentProcessId, 
        personalityTxid: personalityTx.id 
      }
    });

  } catch (error) {
    addLog(deployment.id, 'error', `Agent deployment failed: ${error.message}`);
    updateDeployment(deployment.id, { 
      status: 'failed',
      endTime: new Date().toISOString(),
      error: error.message
    });
  }
}

async function summonAgent(deployment, personalityPrompt) {
  try {
    updateDeployment(deployment.id, { status: 'spawning' });
    addLog(deployment.id, 'info', 'Beginning agent summoning ritual...');

    const wallet = await loadWallet();
    const signer = createDataItemSigner(wallet);
    
    addLog(deployment.id, 'info', 'üéØ Spawning AO process...');
    
    const agentProcessId = await aoSpawn({
      module: "SBNb1qPQ1TDwpD_mboxm2YllmMLXpWw4U8P9Ff8W9vk",
      scheduler: '_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA',
      signer,
      tags: [{ name: 'Name', value: deployment.agentName }]
    });

    addLog(deployment.id, 'info', `‚úÖ Agent's AO Process ID: ${agentProcessId}`);
    updateDeployment(deployment.id, { processId: agentProcessId });

    // Initialize with avatar blueprint
    addLog(deployment.id, 'info', 'üì¶ Initializing agent process with avatar.lua');
    const avatarCodePath = '/app/src/avatar/avatar.lua';
    const avatarCode = await fs.readFile(avatarCodePath, 'utf-8');
    
    await message({
      process: agentProcessId,
      signer,
      data: avatarCode,
      tags: [{ name: 'Action', value: 'Eval' }]
    });

    addLog(deployment.id, 'info', 'üì¶ Agent process initialized with avatar.lua');

    // Store personality on Arweave
    updateDeployment(deployment.id, { status: 'storing_soul' });
    addLog(deployment.id, 'info', 'üíæ Creating permanent soul on Arweave...');
    
    const personalityTx = await arweave.createTransaction({
      data: personalityPrompt
    }, wallet);

    personalityTx.addTag('Type', 'Agent-Personality');
    personalityTx.addTag('Agent-Process-ID', agentProcessId);
    personalityTx.addTag('Agent-Name', deployment.agentName);
    personalityTx.addTag('Content-Type', 'text/markdown');
    personalityTx.addTag('Timestamp', new Date().toISOString());

    await arweave.transactions.sign(personalityTx, wallet);
    await arweave.transactions.post(personalityTx);

    addLog(deployment.id, 'info', `üíæ Agent soul stored on Arweave: ${personalityTx.id}`);

    // Load personality into agent
    addLog(deployment.id, 'info', 'üß† Loading personality into agent...');
    await message({
      process: agentProcessId,
      signer,
      data: personalityPrompt,
      tags: [
        { name: 'Action', value: 'Load-Personality' },
        { name: 'Personality-Txid', value: personalityTx.id }
      ]
    });

    updateDeployment(deployment.id, { 
      status: 'completed',
      endTime: new Date().toISOString(),
      result: { 
        processId: agentProcessId, 
        personalityTxid: personalityTx.id,
        message: '‚ú® Avatar successfully summoned!'
      }
    });

    addLog(deployment.id, 'info', '‚ú® Avatar successfully summoned!');
    addLog(deployment.id, 'info', `Process ID: ${agentProcessId}`);
    addLog(deployment.id, 'info', `Personality Transaction: ${personalityTx.id}`);
    addLog(deployment.id, 'info', 'üåü Summoning ritual complete!');

  } catch (error) {
    addLog(deployment.id, 'error', `Agent summoning failed: ${error.message}`);
    updateDeployment(deployment.id, { 
      status: 'failed',
      endTime: new Date().toISOString(),
      error: error.message
    });
  }
}

async function deployFull(deployment) {
  try {
    addLog(deployment.id, 'info', 'Starting full deployment pipeline');
    
    // Sequential deployment
    await deployGenesis(deployment);
    addLog(deployment.id, 'info', 'Genesis deployment completed');
    
    await deployOracle(deployment);
    addLog(deployment.id, 'info', 'Oracle deployment completed');
    
    await deployAgent(deployment);
    addLog(deployment.id, 'info', 'Agent deployment completed');
    
    updateDeployment(deployment.id, { 
      status: 'completed',
      endTime: new Date().toISOString()
    });
    
    addLog(deployment.id, 'info', 'Full deployment pipeline completed successfully');

  } catch (error) {
    addLog(deployment.id, 'error', `Full deployment failed: ${error.message}`);
    updateDeployment(deployment.id, { 
      status: 'failed',
      endTime: new Date().toISOString(),
      error: error.message
    });
  }
}

const PORT = process.env.PORT || 3032;

// Initialize server with auto-genesis
async function startServer() {
  try {
    console.log('üåü Starting RATi Deployment Service...');
    
    // Initialize genesis transaction before starting server
    await initializeGenesis();
    
    server.listen(PORT, () => {
      console.log(`üöÄ Deployment service running on port ${PORT}`);
      console.log(`üìä WebSocket server ready for real-time updates`);
      console.log(`‚ú® Genesis initialization complete`);
    });
  } catch (error) {
    console.error('‚ùå Failed to start server:', error.message);
    process.exit(1);
  }
}

// Request ID middleware
app.use((req, res, next) => {
  req.requestId = req.headers['x-request-id'] || uuidv4();
  res.setHeader('x-request-id', req.requestId);
  next();
});

// Enhanced error handling middleware
app.use(errorHandler);

// Validate environment on startup
try {
  validateEnvironment();
} catch (error) {
  console.error('Environment validation failed:', error.message);
  process.exit(1);
}

// Start the server
startServer();
